
import { Entity } from '../../components/modeling/steps/Step8Entities';

const snakeCase = (str: string): string => str ? str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`).replace(/^_+/, '') : '';
const pascalCase = (str: string): string => str ? str.replace(/(?:^|[^a-zA-Z0-9])([a-zA-Z0-9])/g, g => g.toUpperCase().charAt(g.length - 1)).replace(/[^a-zA-Z0-9]/g, '') : '';
const camelCase = (str: string): string => {
    if(!str) return '';
    const pc = pascalCase(str);
    return pc.charAt(0).toLowerCase() + pc.slice(1);
}

function generatePackageJson() {
    return JSON.stringify({
        name: "generated-api",
        version: "1.0.0",
        main: "src/index.ts",
        scripts: {
            "dev": "ts-node-dev src/index.ts",
            "build": "tsc",
            "start": "node dist/index.js"
        },
        dependencies: {
            "express": "^4.18.2",
            "cors": "^2.8.5",
            "dotenv": "^16.3.1",
            "jsonwebtoken": "^9.0.2",
            "zod": "^3.22.4",
            "swagger-jsdoc": "^6.2.8",
            "swagger-ui-express": "^5.0.0"
        },
        devDependencies: {
            "@types/express": "^4.17.21",
            "@types/cors": "^2.8.17",
            "@types/jsonwebtoken": "^9.0.5",
            "@types/swagger-jsdoc": "^6.0.4",
            "@types/swagger-ui-express": "^4.1.6",
            "ts-node-dev": "^2.0.0",
            "typescript": "^5.3.3"
        }
    }, null, 2);
}

function generateSwaggerConfig(wizardData: any) {
    const systemName = wizardData.planning?.step1?.systemName || 'Generated API';
    const description = wizardData.planning?.step1?.description || 'API documentation generated by Nexus Platform';
    
    return `
import swaggerJsdoc from 'swagger-jsdoc';

const options: swaggerJsdoc.Options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: '${systemName}',
      version: '1.0.0',
      description: '${description.replace(/'/g, "\\'")}',
    },
    servers: [
      {
        url: 'http://localhost:3001/api/v1',
        description: 'Local development server',
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
        },
      },
    },
    security: [
      {
        bearerAuth: [],
      },
    ],
  },
  apis: ['./src/modules/**/*.routes.ts'], // Path to the API docs
};

export const specs = swaggerJsdoc(options);
    `.trim();
}

function generateIndexTs(entities: Entity[], conferenceData: any) {
    const version = conferenceData.versioning === 'URL Path (/v1)' ? '/v1' : '';
    const imports = entities.map(e => `import ${camelCase(e.name)}Routes from './modules/${camelCase(e.name)}/${camelCase(e.name)}.routes';`).join('\n');
    const uses = entities.map(e => `app.use('/api${version}/${snakeCase(e.name)}s', ${camelCase(e.name)}Routes);`).join('\n');

    return `
import express from 'express';
import cors from 'cors';
import 'dotenv/config';
import swaggerUi from 'swagger-ui-express';
import { specs } from './config/swagger';
${imports}

const app = express();
const port = process.env.PORT || 3001;

app.use(cors());
app.use(express.json());

// Swagger UI
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(specs));

app.get('/api/health', (req, res) => res.status(200).json({ status: 'ok' }));

// --- Application Routes ---
${uses}

app.listen(port, () => {
  console.log(\`API Server running on port \${port}\`);
  console.log(\`Swagger UI available at http://localhost:\${port}/api-docs\`);
});
    `.trim();
}

function generateAuthMiddleware(conferenceData: any) {
    if (conferenceData.authentication !== 'JWT Bearer Token') {
        return '// Autenticação não baseada em JWT selecionada. Implemente sua lógica customizada aqui.';
    }
    return `
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

export const authMiddleware = (req: Request, res: Response, next: NextFunction) => {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ message: 'Acesso negado. Token não fornecido.' });
    }

    const token = authHeader.split(' ')[1];
    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your_secret_key');
        (req as any).user = decoded;
        next();
    } catch (error) {
        res.status(400).json({ message: 'Token inválido.' });
    }
};
    `.trim();
}

// Helper to map entity field types to OpenAPI types
const mapFieldToOpenApi = (field: any) => {
    let type = 'string';
    let format = undefined;
    
    switch (field.type) {
        case 'Integer':
            type = 'integer';
            break;
        case 'Float':
        case 'Decimal':
            type = 'number';
            break;
        case 'Boolean':
            type = 'boolean';
            break;
        case 'Date':
            type = 'string';
            format = 'date';
            break;
        case 'DateTime':
            type = 'string';
            format = 'date-time';
            break;
        case 'UUID':
            type = 'string';
            format = 'uuid';
            break;
        case 'JSON':
        case 'JSONB':
            type = 'object';
            break;
        default:
            type = 'string';
            break;
    }
    return { type, format };
};

function generateEntityModule(entity: Entity, conferenceData: any) {
    const files: Record<string, string> = {};
    const nameCamel = camelCase(entity.name);
    const namePascal = pascalCase(entity.name);
    const nameSnake = snakeCase(entity.name) + 's';
    const basePath = `src/modules/${nameCamel}`;

    // Validation Schema (Zod)
    let zodSchema = `import { z } from 'zod';\n\nexport const ${nameCamel}Schema = z.object({\n`;
    entity.fields.forEach(f => {
        let fieldValidation = 'z.string()'; // Default
        if (f.type === 'Integer' || f.type === 'Float') fieldValidation = 'z.number()';
        if (f.type === 'Boolean') fieldValidation = 'z.boolean()';
        if (f.type === 'Date' || f.type === 'DateTime') fieldValidation = 'z.string().datetime()';
        if (!f.required) fieldValidation += '.optional()';
        zodSchema += `  ${camelCase(f.name)}: ${fieldValidation},\n`;
    });
    zodSchema += `});\n\nexport const create${namePascal}Schema = ${nameCamel}Schema;\nexport const update${namePascal}Schema = ${nameCamel}Schema.partial();`;
    files[`${basePath}/${nameCamel}.validation.ts`] = zodSchema;

    // Service
    files[`${basePath}/${nameCamel}.service.ts`] = `
// Lógica de negócio para ${namePascal}
// TODO: Implementar lógica de banco de dados (Prisma, etc.)

export const ${nameCamel}Service = {
  findAll: async () => { console.log('Buscando todos os ${nameSnake}'); return []; },
  findById: async (id: string) => { console.log(\`Buscando ${nameSnake} com id \${id}\`); return { id }; },
  create: async (data: any) => { console.log('Criando ${nameSnake}', data); return data; },
  update: async (id: string, data: any) => { console.log(\`Atualizando ${nameSnake} com id \${id}\`, data); return { id, ...data }; },
  remove: async (id: string) => { console.log(\`Deletando ${nameSnake} com id \${id}\`); return { id }; },
};
    `.trim();

    // Controller
    files[`${basePath}/${nameCamel}.controller.ts`] = `
import { Request, Response } from 'express';
import { ${nameCamel}Service } from './${nameCamel}.service';
import { create${namePascal}Schema, update${namePascal}Schema } from './${nameCamel}.validation';

export const ${nameCamel}Controller = {
  findAll: async (req: Request, res: Response) => res.json(await ${nameCamel}Service.findAll()),
  findById: async (req: Request, res: Response) => res.json(await ${nameCamel}Service.findById(req.params.id)),
  create: async (req: Request, res: Response) => {
    const validatedData = create${namePascal}Schema.parse(req.body);
    res.status(201).json(await ${nameCamel}Service.create(validatedData));
  },
  update: async (req: Request, res: Response) => {
    const validatedData = update${namePascal}Schema.parse(req.body);
    res.json(await ${nameCamel}Service.update(req.params.id, validatedData));
  },
  remove: async (req: Request, res: Response) => res.json(await ${nameCamel}Service.remove(req.params.id)),
};
    `.trim();

    // Generate Swagger Schemas and Route annotations
    let swaggerComponents = `
/**
 * @swagger
 * components:
 *   schemas:
 *     ${namePascal}:
 *       type: object
 *       properties:
 *         id:
 *           type: string
 *           format: uuid
`;
    // Add fields to main schema
    entity.fields.forEach(f => {
        const { type, format } = mapFieldToOpenApi(f);
        swaggerComponents += `         ${camelCase(f.name)}:
           type: ${type}
${format ? `           format: ${format}` : ''}
`;
    });
    
    // Create Input schema (usually without ID/timestamps, but reusing fields here for simplicity)
    swaggerComponents += `     ${namePascal}Input:
       type: object
       required:
${entity.fields.filter(f => f.required).map(f => `         - ${camelCase(f.name)}`).join('\n')}
       properties:
`;
    entity.fields.forEach(f => {
        const { type, format } = mapFieldToOpenApi(f);
        swaggerComponents += `         ${camelCase(f.name)}:
           type: ${type}
${format ? `           format: ${format}` : ''}
`;
    });
    swaggerComponents += ` */\n`;

    const routeTag = `
/**
 * @swagger
 * tags:
 *   name: ${namePascal}
 *   description: ${namePascal} management
 */
`;

    // Routes
    const authImport = conferenceData.authentication === 'JWT Bearer Token' ? `import { authMiddleware } from '../../middlewares/auth';` : '';
    const authMiddleware = conferenceData.authentication === 'JWT Bearer Token' ? 'authMiddleware, ' : '';
    
    files[`${basePath}/${nameCamel}.routes.ts`] = `
import { Router } from 'express';
import { ${nameCamel}Controller } from './${nameCamel}.controller';
${authImport}

const router = Router();

${swaggerComponents}
${routeTag}

/**
 * @swagger
 * /${nameSnake}:
 *   get:
 *     summary: Retrieve a list of ${namePascal}
 *     tags: [${namePascal}]
 *     responses:
 *       200:
 *         description: A list of ${namePascal}
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/${namePascal}'
 */
router.get('/', ${authMiddleware}${nameCamel}Controller.findAll);

/**
 * @swagger
 * /${nameSnake}:
 *   post:
 *     summary: Create a new ${namePascal}
 *     tags: [${namePascal}]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/${namePascal}Input'
 *     responses:
 *       201:
 *         description: The created ${namePascal}
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/${namePascal}'
 */
router.post('/', ${authMiddleware}${nameCamel}Controller.create);

/**
 * @swagger
 * /${nameSnake}/{id}:
 *   get:
 *     summary: Get a ${namePascal} by ID
 *     tags: [${namePascal}]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: The ${namePascal}
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/${namePascal}'
 *       404:
 *         description: Not found
 */
router.get('/:id', ${authMiddleware}${nameCamel}Controller.findById);

/**
 * @swagger
 * /${nameSnake}/{id}:
 *   put:
 *     summary: Update a ${namePascal}
 *     tags: [${namePascal}]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/${namePascal}Input'
 *     responses:
 *       200:
 *         description: The updated ${namePascal}
 */
router.put('/:id', ${authMiddleware}${nameCamel}Controller.update);

/**
 * @swagger
 * /${nameSnake}/{id}:
 *   delete:
 *     summary: Delete a ${namePascal}
 *     tags: [${namePascal}]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: The deleted ${namePascal}
 */
router.delete('/:id', ${authMiddleware}${nameCamel}Controller.remove);

export default router;
    `.trim();

    return files;
}


export async function generateFullApi(wizardData: any, conferenceData: any): Promise<any> {
    const entities: Entity[] = wizardData.data_modeling?.step8?.entities || [];
    const files: Record<string, string> = {};

    files['package.json'] = generatePackageJson();
    files['src/config/swagger.ts'] = generateSwaggerConfig(wizardData);
    files['src/index.ts'] = generateIndexTs(entities, conferenceData);
    
    if (conferenceData.authentication === 'JWT Bearer Token') {
        files['src/middlewares/auth.ts'] = generateAuthMiddleware(conferenceData);
    }
    
    entities.forEach(entity => {
        Object.assign(files, generateEntityModule(entity, conferenceData));
    });

    // --- Diagram Generation ---
    const firstEntity = entities[0];
    if (firstEntity) {
        const resourceName = snakeCase(firstEntity.name) + 's';
        const sequenceDiagram = `
\`\`\`mermaid
sequenceDiagram
    participant Client
    participant Controller
    participant Service
    participant Database

    Client->>+Controller: POST /api/v1/${resourceName}
    Controller->>+Service: create(data)
    Service->>+Database: INSERT into ${resourceName}
    Database-->>-Service: created record
    Service-->>-Controller: createdEntity
    Controller-->>-Client: 201 Created
\`\`\`
        `.trim();
        files['diagrams/diagrama_de_sequencia.md'] = sequenceDiagram;
    }

    let componentDiagram = '```mermaid\ngraph TD\n    subgraph "Backend Application"\n';
    Object.keys(files).forEach(path => {
        if (path.startsWith('src/')) {
            const fileName = path.split('/').pop() || '';
            const nodeName = fileName.replace('.ts', '').replace('.', '_');
            componentDiagram += `        ${nodeName}["${fileName}"]\n`;
        }
    });
    entities.forEach(entity => {
        const entityNameSnake = camelCase(entity.name);
        componentDiagram += `        ${entityNameSnake}Controller --> ${entityNameSnake}Service\n`;
    });
     if (files['src/middlewares/auth.ts']) {
        entities.forEach(entity => {
            const entityNameSnake = camelCase(entity.name);
            componentDiagram += `        ${entityNameSnake}Routes --> auth\n`;
        });
    }
    componentDiagram += '    end\n```';
    files['diagrams/diagrama_de_componentes.md'] = componentDiagram;


    return { files };
}
